; Brett's start on FORTH in OWL
;
; Arguments may have spaces,
; so semicolons are required for comments.
;
; We now have these pesudo-ops: org rmb equ fcw fcb
; We have 3 ways of writing numeric args:
;    decimal, $hex, 'c  (for one character c)
; The only arithmetic supported is + and -
; TODO: full arithmetic evaluator.

	org $00

W	rmb 2   ; working reg
T	rmb 2   ; Top Of Stack
SP	rmb 2   ; data stack pointer
RP	rmb 2   ; return stack pointer
PC	rmb 2   ; Forth PC
I	rmb 4   ; Fetched Instruction

	org $20

; just testing fcw and fcb
nando	equ $1234
	fcw nando
	fcb 'H'
	fcb 'E'
	fcb 'L'
	fcb 'L'
	fcb 'O'
	fcb 0

	org $42

start           ; the `start` label is where IPL jumps to.
next:	setb 0
	ldh PC
	ldl PC + 1
	mv m, a
	sta I
	incw
	mv m, a
	sta I+1
	incw
	sth PC
	stl PC+1
; jump to I
	ldh I
	ldl I+1
	seta 1
	setb 0
	bnz

drop:
	ldh SP ; inc SP
	ldl SP+1 ; inc SP
	incw
	incw
	sth SP
	stl SP+1

	seta 1 ; Jump to next
	setb 0
	seth next
	setl next+1
	bnz

; Local labels with initial @.
; Totally empty lines (not even a comment) separate local blocks.
block1	seta 0
@x	setb 1
	seth 2
	setl @x

block2	seta 0
@x	setb 1
	seth 2
	setl @x

block3	seta 0
@x	setb 1
	seth 2
	setl @x
	; same block
	setl @x


TryMacros:

SET_W	macro _b,_h,_l
	setb _b
	seth _h
	setl _l
	endmacro

	seta 100
	SET_W 1,2,3
	seta 200
	SET_W 2,4,6
	seta 300

; A macro expansion is a block of its own.
LOOP	macro
	setb 0
@here
	seth 0
	setl @here    ; works if on the same page
	seta 1
	bnz
	endmacro

	LOOP
	LOOP
	LOOP

; Numbers are 24-bit unsigned, like the W register.
	assert ($FFFFFF + 1) == 0
	assert ($FFFFFF + 2) == 1

; Five built-in functions:
;   B(num)    -- the most significant byte
;   H(num)    -- the middle byte
;   L(num)    -- the least significant byte
;   HL(num)   -- the lowest 16 bits
;   W(most:middle:least)  -- compose a number from most, middle, and least bytes.
; Notice colons are used in the W(::) function, not commas.

X1	equ $456789
	setb B(X1)    ; should be $45
	seth H(X1)    ; should be $67
	setl L(X1)    ; should be $89

	assert B(X1) == $45
	assert H(X1) == $67
	assert L(X1) == $89

	// using hex numbers:
W2	equ W($22:$33:$44)   ; use colons, not commas, to separate args to W()
	setb B(W2)    ; should be $22
	seth H(W2)    ; should be $33
	setl L(W2)    ; should be $44
	
	assert B(W2) == $22
	assert H(W2) == $33
	assert L(W2) == $44
	assert HL(W2) == $3344
	
	// using decimal numbers:
D2	equ W(22:33:44)   ; use colons, not commas, to separate args to W()
	setb B(D2)    ; should be 22
	seth H(D2)    ; should be 33
	setl L(D2)    ; should be 44
	
	assert B(D2) == 22
	assert H(D2) == 33
	assert L(D2) == 44
	assert HL(D2) == 8492
	
; check math.  Must fully parenthesize -- there is no operator precedence!
	assert 3 < 9
	assert (3 < 9) == 1
	assert (3 > 9) == 0
	assert (3 <= 9) == 1
	assert (3 >= 9) == 0

	assert 123 == 123
	assert (123 == 123) == 1
	assert (123 != 123) == 0
	assert (123 <= 123) == 1
	assert (123 >= 123) == 1

	assert 4 != 7
	assert (4 == 7) == 0
	assert (4 != 7) == 1

	assert (3 + 9) == 12
	assert (3 - 9) == $fffffa
	assert (3 * 9) == 27
	assert (3 / 9) == 0
	assert (3 % 9) == 3
	assert (31 / 9) == 3
	assert (31 % 9) == 4

	assert ($1234 << 8) == $123400
	assert ($1234 << 16) == $340000
	assert ($1234 >> 8) == $12

	assert $003400 == ($123456 & $00ff00)
	assert $12ff56 == ($123456 | $00ff00)
	assert $12cb56 == ($123456 ^ $00ff00)

@1	equ ((1+2)*(3+4))
@2	equ ( (1+ 2) * ( 3+4) )
@3	equ (@1 * @2) == 441
   	assert (@1 * @2) == 441
	assert (((1+2)*(3+4)) * ( (1+ 2) * ( 3+4) )) == 441
	assert (22==22) == (23==23)
	assert (22==22) != (23==24)

	// We allow 0x as well as $, to mark hex
	// We allow 0o as well as 0, to mark octal
	// We allow 0b to mark binary
	assert 1
	assert (1)
	assert 0x001000
	assert 0xFFFFFF
	assert 0xFFFFFF == (0 - 1)
	assert 0xFF == 255   ; hex
	assert 077 == 63     ; octal
	assert 0o77 == 63    ; octal
	assert 0b1010 == 10  ; binary
	assert (0b1010) == (10)  ; binary
	assert ((0b1010) == (10))  ; binary

	; this macro defines a label
Square	MACRO _num_,_label_
_label_ equ _num_ * _num_
	EndMacro

	Square 12, Gross
	assert Gross == 144

; END
